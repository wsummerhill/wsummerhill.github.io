---
title: "Introductory Malware Development (Malware Dev 101)"
date: 2024-02-01
categories: redteam
published: false
---

## Malware Development Introduction

Getting into malware development can be a daunting task. Knowing where and how to get started isn't always that obvious as there are tons of resources out there (both free and paid) but little information on what to start with or focus on first.<br />

The idea of this post is to help make it a bit easier for people starting in malware development by sharing some general direction, tips, and resources I personally have used and found very useful throughout my experiences.<br />

The overall goal of our malware development efforts is typically to execute shellcode which we can use to gain an initial foothold in an environment and perform post-exploitation activites. Our objective is to obfuscate our payloads and shellcode in a way that bypass endpoint security protections (more on this later) to establish that initial foothold undetected.<br />

This content will try to be as vendor-agnostic as possible regardless of the security solutions you're going up against. I will also walk through different code samples using both C++ and C# as these are some of the most common and well-documented malware development languages. Newer languages like [Go](https://go.dev/) and [Rust](https://www.rust-lang.org/) are gaining populatity, but for the sake of learning fundamentals we'll stick to C-based languages.

*Note: In this post we're only going to be covering Windows malware development.*<br />

## Content Overview

- [Malware Dev 101](#malware-dev-101)
- AV & EDR
- Evasion - Obfuscation
- Evasion - Encryption
- [Recommended Resources](#recommended-resources)

## Malware Dev 101

To get started with some hands-on work, let's get a basic understanding of the requirements needed to launch shellcode in our first malicious program. In order to execute shellcode, we have to familiarize ourselves with the (Win32 API)[https://learn.microsoft.com/en-us/windows/win32/api/]. Using the Win32 API allows us to interact with backend features of the Windows operating system.<br />

The main Windows API functions we need are as follows:
- [VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc): This is our initial function used to allocate space in memory where we are going to place our shellcode and should be equivalent to the size of the shellcode.
- [RtlMoveMemory](https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory) (C/C++) or [Marshal.Copy](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.copy?view=net-8.0) (C#): These functions are used to copy memory from one source (our shellcode) to a target destination, which will be the address we just allocated for our shellcode with **VirtualAlloc**.
- [VirtualProtect](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect): This function is used to change the protections on a region of memory, and in our case to make the shellcode region Executable.
- [CreateThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) and [WaitForSingleObject](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject): **CreateThread** is used to create a new thread in the current process that's pointing to the start of our shellcode. **WaitForSingleObject** is called after CreateThread to delay execution until the previous thread completes, which our case is required to wait until the shellcode execution finishes.<br />

Here's a C++ sample of what this code looks like combined:
```cpp

```

## Recommended Resources
